/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package linkedList;

public class LinkedList{

  Node head;
  int counter;
  int length;

  public LinkedList(){
    this.head=null;
    this.counter=0;
    this.length=0;
  }


  public LinkedList reverse(LinkedList ls) {
    Node  prev = null;
    Node  current = head;
    Node  next = null;

    while (current != null) {
      // Before changing next of current,
      // store next node
      next = current.next;
      // Now change next of current
      // This is where actual reversing happens
      current.next = prev;
      // Move prev and curr one step forward
      prev = current;
      current = next;
    }
    head = prev;
    return ls;
  }

  public LinkedList  zipLists( LinkedList list1,LinkedList list2){


    LinkedList newLinkedList = new LinkedList();
    if (list1.head == null && list2.head == null) {
    }
    else if (list1.head == null) {
      newLinkedList = list2;
      return newLinkedList;
    }
    else if (list2.head == null) {
      newLinkedList = list1;
      return newLinkedList;
    }
    Node current1 = list1.head;
    Node current2 = list2.head;

    while (current1.next != null && current2.next != null) {
      newLinkedList.append(current1.value);
      newLinkedList.append(current2.value);
      current1 = current1.next;
      current2 = current2.next;
    }
    newLinkedList.append(current1.value);
    newLinkedList.append(current2.value);

    if (current1.next != null) {

      while (current1.next != null) {
        current1 = current1.next;
        newLinkedList.append(current1.value);
      }
    }
    else if (current2.next != null) {

      while (current2.next != null) {
        current2 = current2.next;
        newLinkedList.append(current2.value);
      }
    }
    return newLinkedList;
  }

  public int FindMax(){
    Node curr=head;
    int max=head.value;
    while (curr!=null){
      if(curr.value>max){
        max=curr.value;
      }
      curr=curr.next;
    }
    return max;
  }

  public int FindSecondMax(){
    Node curr=head;
    int max=head.value;
    int secondMax=0;
    while (curr!=null){
      if(curr.value>max){
        max=curr.value;
      }
      if(curr.value>secondMax && curr.value!=max){
        secondMax=curr.value;
      }
      curr=curr.next;
    }

    return secondMax;
  }

  public int FindMin(){
    Node curr=head;
    int min=head.value;
    while (curr!=null){
      if (curr.value<min){
        min=curr.value;
      }
      curr=curr.next;
    }
    return min;
  }

  public int FindSecondMin(){
    Node curr=head;
    int min = head.value;
    int secondMin=0;
    while (curr!=null){
      if(curr.value<min){
        min=curr.value;
      }
      if(curr.value<secondMin && curr.value!=min){
        secondMin= curr.value;
      }
      curr=curr.next;
    }
    return secondMin;
  }

  public void removeDuplicate(){
    Node curr=head;
    if(curr==null){
      return;
    }

    while (curr.next!=null){
      if (curr.value==curr.next.value){
        curr.next=curr.next.next;
      }
        curr=curr.next;

    }

  }

  public void deleteSpecific(int value){
    Node curr=head;
    while (curr.next!=null){
      if(curr.next.value==value){
        curr.next=curr.next.next;
      }
      curr=curr.next;
    }
  }

  public int findMiddleValue(){
    Node curr=head;
    int length=0;
    float size=0;
    int middleValue=0;
    while (curr!=null){
      size++;
      curr= curr.next;
    }

      Node newCurr=head;
    while (newCurr!=null){
      length++;

      if(length==Math.round(size/2)){
//        System.out.println(length);
//        System.out.println(size/2);
        middleValue=newCurr.value;
      }
        newCurr=newCurr.next;
    }
    return middleValue;
  }

  public void deleteMiddle(){
    Node curr1= head;
    int size=0;
    int mid=0;
    while(curr1!=null){
      size++;
      System.out.println(size);
      curr1=curr1.next;
    }
    if(size%2==1){
      mid=(size-1)/2;
    }else{
      mid=size/2;
    }
    System.out.println(mid);
    Node curr2=head;

    while(curr2!=null){
      length++;
      if (length == mid){
        curr2.next=curr2.next.next;
      }
      curr2=curr2.next;
    }

  }

  public Node  midValue(LinkedList list ){
    Node current = head;
    int counter = 0;
    while (current!=null){
      counter++;
      current = current.next;
    }
    Node mid = list.head;
    if(counter % 2 == 1){
      counter = counter / 2;
    }
    else{
      counter = counter - 1;
      counter = counter / 2;
    }
    for(int i = 0 ; i < counter ; i++){
      mid = mid.next;

    }
    System.out.println("The Middle value : " + mid.value);
    return mid;
  }
  public int kthFromEnd(int k) throws Exception {
      Node current = head;
      if (k > 0 && k <= counter) {
        while (current.next != null) {

          if ((counter - k) == length) {
            break;
          }
          current = current.next;
          length++;
        }
        return current.value;
      }
      else{
        throw new Exception("Exception message");
      }
    }




    public void InsertBefore(int value,int newValue){
      Node newNode = new Node(newValue);
      Node current =head;
      if(current.value==value){
        newNode.next=current;
        head=newNode;
      }
      while (current.next!=null){

        if(current.next.value ==value){

          newNode.next=current.next;
          current.next=newNode;
          break;
        }
        current=current.next;
      }
    }

    public void InsertAfter(int value , int newValue){
      Node newNode = new Node(newValue);
      Node current=head;

      while (current.next!=null){

        if(current.value ==value){
          newNode.next=current.next;
          current.next=newNode;
          break;
        }
        current=current.next;
      }
      if(current.next==null && current.value==value){
        newNode.next=null;
        current.next=newNode;
      }

    }

    public void insert(int value){
      Node newNode = new Node(value);
      newNode.next=head;
      head=newNode;

      counter++;
    }


    public void append(int value){
      Node newNode =new Node(value);
      if (head == null) {
        head = newNode;
      } else {
        Node current = head;
        while (current.next != null) {

          current = current.next;
        }
        current.next = newNode;

        counter++;
      }
    }

    public Boolean Includes(int value){
    Boolean cond =false;
      Node current=head;
      if(head.value==value){
        cond=true;
      }
      while (current.next!=null){

      if(current.value==value){
        cond=true;
      }
      current=current.next;
    }
    return cond;
    }


    public String ToString(){
      String result="";
      Node current = head;
      while (current!=null){
        result=result+"{"+current.value+"}->";
        current=current.next;
      }
      result=result+"X";
      return "head ->"+result;
    }

}
